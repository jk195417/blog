{"posts":[{"title":"幫 Free Dyno Heroku App 自訂網址再透過 CloudFlare 加上 https","text":"近年來資安漏洞頻傳，透過 http 明文傳送機敏資訊造成的傷害也早已不是什麼新聞了，替網站加上 https 是勢在必行。 瀏覽器網址列旁的綠色鎖頭有沒有帶來一種安全的感覺。 如何免費得到 https 保護呢 Let’s Encrypt - 自行申請免費的 SSL CloudFlare - 與他人共用 CloudFlare 免費提供的 SSL 本次的目標網站是架設在 Heroku 上的 Free Dyno 型應用程式，Free Dyno 其實已經有提供免費的 https 給預設的 &lt;app-name&gt;.herokuapp.com 但是如果想幫 Free dyno 類型的網站加上 SSL 支援，沒有辦法使用方法 1 的 Let’s Encrypt 簽發憑證這個方式，只好透過方法 2 CloudFlare 來處理： 對於架在 Heroku 上的網站來說，把 free dyno 升級成 hobby dyno，就會附贈免費的 Heroku SSL，其實是最省時省力的 https://blog.heroku.com/announcing-automated-certificate-management 需要 一個 Free Dyno Heroku App 一個 Domain Name 註冊 CloudFlare 步驟Heroku 設定 Custom Domain到 Heroku Dashboard 選擇目標網站應用程式的 Setting 頁籤 Domains and certificates 設定的地方點選 Add domain，填入你的網域 CloudFlare 設定 DNS到 CloudFlare 輸入你的網域 接者 CloudFlare 會去調出你的網域的 Nameserver 供應商的 DNS 設定 新增 CNANE，Name 填入子網域如 www 或根網域 @，Value 填入 Heroku 預設的網址 &lt;app-name&gt;.herokuapp.com。記得要讓要用的 Record 們的橘燈都亮起來喔。 根網域通常需要 A Record 填入 IP Address，Heroku App 提供的網址為浮動 IP，只能透過 Heroku 提供的網址用 CNAME flattening 動態指向過去，才能指定根網域。CloudFlare 剛好有提供 CNAME flattening，想要讓根網域直接對應到 Heroku app，新增 CNANE，Name 填入 @，Value 一樣填入 Heroku 預設的網址 &lt;app-name&gt;.herokuapp.com。 CloudFlare 選擇方案 Free 不解釋 更改網域 Nameservers把網域的 Nameservers 改成 CloudFlare 提供的 Nameservers（DNS 頁籤往下翻），這樣一來，剛剛在 CloudFlare 設定的 DNS 才會生效。 NS 設成 CloudFlare：流量 -&gt; CloudFlare -&gt; Heroku 到當初買網址的網域供應商平台上做設定，EX: Godaddy, Gandi.net, Namecheap, Hover … 以 Hover 為例 設定成功後會在 Overview 看到 Status: Active 如： 啟用 SSL點 CloudFlare Crypto 頁籤，SSL 的部分 Off 設定為 Full 或 Flexible 先說結論：選 Full 憑證通過需要一點時間，當看到 Status Active Certificate 恭喜你，已經能透過 https 訪問網址了!（通過的時間約15分至1天不等） 官方表示免費方案憑證發行等24小時都是正常情況，不想等就花錢啊，15分讓你上線。 https://support.cloudflare.com/hc/en-us/articles/203267234-Can-I-speed-up-the-activation-of-the-free-SSL-option 在本頁 Status 的地方可以看到目前憑證發行的進度。 進度順序：Initializing Certificate -&gt; Authorizing Certificate -&gt; Issuing Certificate -&gt; Active Certificate 等 SSL 憑證發行太久用 Chrome 瀏覽會噴錯誤訊息： 123這個網站無法提供安全連線&lt;domain&gt; 使用了不支援的通訊協定。ERR_SSL_VERSION_OR_CIPHER_MISMATCH` 如果超過一天了憑證還是沒有發下來，你可以： 檢查設定有沒有出錯 https://support.cloudflare.com/hc/en-us/articles/200170566-Why-isn-t-SSL-working-for-my-site CloudFlare &gt; Select Website &gt; Overview &gt; Advanced &gt; Delete，然後把 Nameservers 改回預設值，再重新跑一次 [CloudFlare 設定 DNS](## CloudFlare 設定 DNS)，等了三天 親測有效! 到 Support 發票，然後到官方論壇 https://community.cloudflare.com/t/ssl-delays-authorizing-certificate/3682 求救，許多前輩的過關案例在此。 把 http 請求全部導向 https（選擇性）等憑證發下來在用 CloudFlare &gt; Select Website &gt; Crypto &gt; Always use HTTPS &gt; On 參考資料 https://devcenter.heroku.com/articles/custom-domains#configuring-dns-for-root-domains https://support.cloudflare.com/hc/en-us/articles/205893698 https://robots.thoughtbot.com/set-up-cloudflare-free-ssl-on-heroku https://support.cloudflare.com/hc/en-us/articles/203445970-What-does-SSL-Authorizing-mean-after-activating-free-Universal-SSL","link":"/free-heroku-app-custom-domain-name-on-https-use-cloudflare/"},{"title":"幫 Github Pages 自訂網址再透過 CloudFlare 加上 https","text":"上一篇 Post not found: free-heroku-app-custom-domain-name-on-https-use-clouldflare 之後，這次要來幫 Github Pages 加上自訂網址與 https。本次就跳過了一些上次說過的事情（有興趣的讀者可以自行前往閱讀），直接帶大家走一遍設定流程。 Github Pages官方介紹：https://pages.github.com/只要會一點 git 即可輕鬆且免費地部署靜態資源到 Github Pages 上，通常被拿來建立 Blog，或是做成文檔和 Demo 網頁，也可以放一些簡單的 SPA 網頁應用。 需要 Github 帳號 Domain name CloudFlare 帳號 步驟這邊以我買的網域：https://yanghongxin.com 和我的 Github： https://github.com/jk195417 作為例子 Github 設定 CNAME到自己的 帳號.github.io 的 Github Repo 沒有的話就開一個吧。參閱 https://guides.github.com/features/pages/ 點選 Setting 頁籤 至 Github Pages 設定 Custom domain，它會幫你在此 repo 下建立一個 CNAME 檔案，當你瀏覽這個 Github Pages 時，網址顯示的就會是你自定的網址而不是 Github Pages 提供的網址。 CloudFlare 設定 DNSCloudFlare &gt; Add site &gt; 填入你的網域 接者 CloudFlare 會去調出你的網域的 Nameserver 供應商的 DNS 設定 新增 CNANE，Name 填入子網域如 www 或根網域 @，Value 填入 GitHub Pages 預設的網址 &lt;username&gt;.github.io。記得要讓要用的 Record 們的橘燈都亮起來喔。 CloudFlare 選擇方案 Free 一樣不解釋 更改網域 Nameservers把網域的 Nameservers 改成 CloudFlare 提供的 Nameservers（DNS 頁籤往下翻），這樣一來，剛剛在 CloudFlare 設定的 DNS 才會生效。 NS 設成 CloudFlare：流量 -&gt; CloudFlare -&gt; Github 到當初買網址的網域供應商平台上做設定，EX: Godaddy, Gandi.net, Namecheap, Hover … 以 Godaddy 為例 設定成功後會在 Overview 看到 Status: Active 如： CloudFlare 開啟 SSLCloudFlare &gt; Crypto &gt; SSL 選 Full，等上個15分鐘至一天，若是超過一天都還沒好的話在做下面的步驟。 SSL 憑證等待過久請看Post not found: free-heroku-app-custom-domain-name-on-https-use-clouldflare 上一篇的 等 SSL 憑證發行太久 章節 把 http 請求全部導向 https（選擇性）等憑證發下來在用 CloudFlare &gt; Select Website &gt; Crypto &gt; Always use HTTPS &gt; On 參考連結 https://blog.cloudflare.com/secure-and-fast-github-pages-with-cloudflare/","link":"/github-pages-custom-domain-on-https-use-cloudflare/"},{"title":"好用的軟體 for Mac OSX （一般使用者）","text":"每個軟體會附上官網連結，有支援透過 Homebrew 一行指令安裝的話會一起把指令附上。 前言感謝家人在我升大學的那年，讓我買了這台 13” MacBook Air。年少無知，一開始買 MacBook 的原因真的是因為看起來很潮。 輕薄，高續航，順暢的使用者體驗等等優點都是矇到的。 網路上連文都沒爬，就下手買了個硬碟 256G，Ram 4G 的機型。 也就沒有看到各種無用的跑分數據，或是遊戲支援度超低這些缺點啦 好險當初只有做錯這麼一個選擇：Ram 沒升 8G。 萌新拿到電腦的第一件事居然是去圖書館翻 Mac 的使用說明書，結果誤觸 Xcode，程式生涯從此開始。 廢話完了，進入正題。 因為軟體實在是太多了，所以這裏分成 3 篇系列文章來說 導覽好用的軟體 for Mac OSX （一般使用者） 影音 音樂 繪圖 遊戲 Popcorn Time Spotify Paintbrush OpenEmu IINA Vox PPSSPP Shazam 通訊 筆記 團隊溝通 Telegram Desktop Bear Slack Franz Evernote Flowdock Station Jandi 好用的軟體 for Mac OSX （進階使用者）撰寫中… 遠端連線 輔助工具 系統管理 好用的軟體 for Mac OSX （程式設計師）撰寫中… 編輯器 資料庫 HTTP Client 套件管理 Git 文檔 虛擬機 終端機 影音Popcorn Timehttps://popcorntime.sh/ 透過 P2P 看電影，無廣告或病毒，操作便利。 IINAhttps://lhc70000.github.io/iina/ 1brew cask install iina 現代化的影片播放器，基於 MPV，UI 簡潔。 音樂Spotifyhttps://www.spotify.com/ 1brew cask install spotify 大家都知道的串流音樂，免費版聽個 30 分鐘左右會插個短短的廣告，還算可以接受，提供高音質的音樂，社群功能，協作播放清單這些已經非常優秀了，最令人驚豔的是其 推薦系統，除了能夠準確的推薦喜歡聽的曲風外，偶爾還會推薦些嚐鮮式的音樂，讓聽習慣這種風格的人還是能夠去嘗試發掘其他的還沒愛上的曲風。 Voxhttps://vox.rocks/mac-music-player 1brew cask install vox 在 Mac 上放歌除了 Apple Music 使用者以外應該不會打開 itunes 吧，Vox 是個輕量音樂播放器，你看看開起來的流暢性，管理音樂存放的位置也相對的比較自由，讓音樂播放器回歸音樂播放器。 Shazamhttps://www.shazam.com/ 大名鼎鼎的歌曲辨識軟體，會在背景聆聽周遭音樂，辨識並且記錄下來是哪首曲子。建議 沒有要用的時候就把它關掉 吧，不然多增加能耗跟個人隱私的疑慮（背景收音）。 通訊Telegram Desktophttps://desktop.telegram.org/ 1brew cask install telegram-desktop 自由、技術力 Max、無敵的通訊平台，可惜的是在台灣還沒大紅大紫，缺點就是朋友還沒開始用的 Telegram，等你們都加入後就沒有缺點啦！快來加我好友救我脫離邊緣人 QQ https://t.me/hong_xin Franzhttps://meetfranz.com/ 1brew cask install franz Stationhttps://getstation.com/ 1brew cask install station 繪圖Paintbrushhttps://paintbrush.sourceforge.io/ 1brew cask install paintbrush 修圖軟體 &gt; Paintbrush &gt; 預覽程式。有時候需要一些簡單的繪圖功能，又不想請出 Photoshop 之類的 牛刀，這種小畫家類型的軟體絕對是首選！ 筆記Bearhttp://www.bear-writer.com/ Evernotehttps://evernote.com/ 1brew cask install evernote 團隊溝通Slackhttps://slack.com/ 1brew cask install slack Flowdockhttps://www.flowdock.com/ 1brew cask install flowdock Jandihttps://www.jandi.com/landing/zh-tw 1brew cask install jandi 遊戲OpenEmuhttps://openemu.org/ 1brew cask install openemu 管理遊戲與遊戲模擬器核心，可以透過這個軟體快速下載其他模擬器或一些開源遊戲。 PPSSPPhttps://www.ppsspp.org/ 1brew install ppsspp PSP 模擬器，可以在 Mac 上順暢的玩 PSP 遊戲。","link":"/recommend-mac-softwares/"},{"title":"用 Hexo 建立 Blog","text":"安裝 Hexo1yarn global add hexo-cli 建立 blog 專案 1hexo init blog 主題設定用 git submodule 管理主題，這裡使用 yilia 先 Fork https://github.com/litten/hexo-theme-yilia 到 https://github.com/jk195417/hexo-theme-yilia 添加成 git submodule 到專案的 themes/yilia 1git submodule add https://github.com/jk195417/hexo-theme-yilia.git themes/yilia 修改_config.yml 1theme: yilia 安裝外掛hexo-generator-json-content1yarn add hexo-generator-json-content _config.yml 加上 12345678910111213141516171819# hexo-generator-json-contentjsonContent: meta: false pages: false posts: title: true date: true path: true text: false raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true hexo-generator-sitemap1yarn add hexo-generator-sitemap _config.yml 加上 12sitemap: path: sitemap.xml hexo-generator-feed1yarn add hexo-generator-feed _config.yml 加上 1234feed: type: atom path: atom.xml limit: 20 再到 themes/yilia/_config.yml 修改 12subnav: rss: &quot;/atom.xml&quot; 部署至 Github Page至 _config.yml 填寫部署配置 123deploy: type: git repo: &quot;https://github.com/jk195417/blog.git&quot; 指令 1234# 生成靜態文件$ hexo g# 部屬hexo d","link":"/use-hexo-to-create-blog/"},{"title":"為 Ubuntu 18.04 LTS 安裝 Nvidia GPU driver","text":"列出支援的顯示卡驅動： 1ubuntu-drivers devices 我這邊使用 Nvidia GTX 1060 6G，當前的驅動版本為 415，若是列出的版本太舊(390)，請執行下面這行把 Nvidia Driver 加入 apt 的來源中： 123sudo add-apt-repository ppa:graphics-drivers/ppasudo apt-get updateubuntu-drivers devices 看看是否有更新的驅動程式版本可以使用。 接著安裝執行ubuntu-drivers devices所列出來 recommended 的驅動程式，安裝完畢後重新開機： 123sudo apt install nvidia-driver-415sudo apt install nvidia-settingssudo reboot 檢查當前的顯示卡驅動： 1nvidia-smi","link":"/install-nvidia-gpu-driver-on-ubuntu-18-04-lts/"},{"title":"為 Ubuntu 18.04 LST 安裝 Python 3.6","text":"原則上，Ubuntu 18.04.1 LTS 已經內建 Python 3 了，保險起見先檢查一下： 123sudo apt updatesudo apt upgradepython3 -v 此時的 Python 的版本應有 3.6 以上，我的版本為 3.6.7。 安裝 pip 3 接著安裝 Python 的套件管理模組 pip，和一些常用的開發工具： 12sudo apt install python3-pipsudo apt install build-essential libssl-dev libffi-dev python3-dev 安裝 Python 3 Virtual EnvironmentVirtual Environment 可以把特定的 Python 套件安裝在此環境下，避免全域安裝，搞亂系統的 Python 環境： 1sudo apt install python3-venv 設置虛擬環境： 123mkdir ~/py3venvcd ~/py3venvpython3 -m venv pip_set 此時會建立一個資料夾位於 ~/py3venv/pip_set/，接著使用下列指令開關虛擬環境： 1234# 啟用 dcard_crawler 這個 virtual environmentsource ~/py3venv/pip_set/bin/activate# 關閉deactivate","link":"/install-python-3-6-on-ubuntu-18-04-lts/"},{"title":"為 Ubuntu 18.04 LST 安裝 Tensorflow 1.12 with GPU support","text":"執行完之前介紹的 Post not found: Install-Nvidia-GPU-driver-on-Ubuntu-18-04-LTS 與 Post not found: Install-Python-3-6-on-Ubuntu-18-04-LST 後，就可以為我們的作業系統安裝能透過 GPU 運算的 TensorFlow 啦。 當前的 TensorFlow 版本為 1.12，只支援 CUDA 9.0，當前 CUDA 9.0 的 cuDNN 版本為 7.4.2。 安裝 CUDA 至 https://developer.nvidia.com/cuda-90-download-archive 下載安裝，選擇 Linux+x86_64+Ubuntu+17.04+runfile(local)，下載至 ~/下載/，並透過下列指令執行： 1sudo sh ~/下載/cuda_9.0.176_384.81_linux.run --override Installing with an unsupported configuration 回答 yes Install NVIDIA Accelerated Graphics Driver 回答 no 安裝完畢後將 CUDA 執行檔加入系統變數 PATH 中，在 ~/.bashrc 或 ~/.zshrc 中加入這兩行： 12export PATH=&quot;$PATH:/usr/local/cuda-9.0/bin&quot;export LD_LIBRARY_PATH=&quot;$LD_LIBRARY_PATH:/usr/local/cuda/lib64&quot; 安裝 cuDNN到 https://developer.nvidia.com/rdp/cudnn-download，選擇 Download cuDNN v7.4.2 (Dec 14, 2018), for CUDA 9.0 的 cuDNN Library for Linux，將檔案下載至 ~/下載/： 1234567# 解壓縮tar -xzvf cudnn-9.0-linux-x64-v7.4.2.24.tgz# 複製這些檔案到 CUDA 套件安裝處sudo cp cuda/include/cudnn.h /usr/local/cuda-9.0/includesudo cp cuda/lib64/libcudnn* /usr/local/cuda-9.0/lib64# 給予所有使用者讀取的權限sudo chmod a+r /usr/local/cuda-9.0/include/cudnn.h /usr/local/cuda-9.0/lib64/libcudnn* 安裝 libcupti1sudo apt-get install libcupti-dev 安裝 TensorFlow with GPU Support1234# 建議啟用 venvsource ~/py3venv/pip_set/bin/activate# 安裝 tensorflowpip3 install --upgrade tensorflow-gpu 進入 python3 console 測試是否能執行： 12# terminalpython3 123# python3 consolefrom tensorflow.python.client import device_libdevice_lib.list_local_devices()","link":"/install-tensorflow-1-12-with-gpu-support-on-ubuntu-18-04-lts/"},{"title":"手把手帶你使用 baidu-aip 的情緒分析服務","text":"Google 的自然語言處理雖然非常的強大，但是中文的情緒分析並非他的強項，目前中文的自然語言處理研究出處非常多是出於中國大陸，所以當需要用到中文的情緒分析時， 百度 AI 開放平台 就成為我們的首選啦。 平台目前的收費非常的便宜，例如本次介紹的 情感傾向分析接口，提供了 5QPS 免費額度，每秒免費請求 5 次超佛心的啊！根本就相當於不用錢。 注意！要註冊百度帳號必須要有 +86 開頭的中國手機門號喔。 使用百度 AI 開放平台的情緒分析服務很簡單，步驟就 4 個。 註冊帳號 創建 自然語言處理 應用 獲取 access_token 使用 情感傾向分析接口 註冊帳號需要 中國手機門號 作認證 註冊成功後完成信箱驗證，即可開始使用百度 AI 開放平台的服務啦。 創建自然語言處理應用 從左邊的導覽列選擇，產品服務 &gt; 人工智能 &gt; 自然語言處理，就能來到自然語言處理應用程式的管理介面。 點選創建應用 勾選想使用的服務，填入應用程式的描述。 待會會使用到 API Key與 Secret Key，把它記起來並小心保管，這就相當是使用此服務的帳號密碼囉。 獲取 access_tokenaccess_token有效期為 1 個月，過期就得再次索取。 POST 到 https://aip.baidubce.com/oauth/2.0/token grant_type 值填 grant_type client_id 值填你的 api_key client_secret 值填你的 secret_key 以 curl 為例 1curl -i -X POST &quot;https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=your_api_key&amp;client_secret=your_secret_key&quot; 索取 access_token 成功會得到回應： 12345678{ &quot;refresh_token&quot;: &quot;25.b55fe1d287227ca97aab219bb249b8ab.315360000.1798284651.282335-8574074&quot;, &quot;expires_in&quot;: 2592000, &quot;scope&quot;: &quot;public wise_adapt&quot;, &quot;session_key&quot;: &quot;9mzdDZXu3dENdFZQurfg0Vz8slgSgvvOAUebNFzyzcpQ5EnbxbF+hfG9DQkpUVQdh4p6HbQcAiz5RmuBAja1JJGgIdJI&quot;, &quot;access_token&quot;: &quot;24.6c5e1ff107f0e8bcef8c46d3424a0e78.2592000.1485516651.282335-8574074&quot;, &quot;session_secret&quot;: &quot;dfac94a3489fe9fca7c3221cbf7525ff&quot; } 錯誤會看見這個： 1234{ &quot;error&quot;: &quot;invalid_client&quot;, &quot;error_description&quot;: &quot;unknown client id&quot; } 參考 http://ai.baidu.com/docs#/Auth/top 使用情感傾向分析接口POST 到 https://aip.baidubce.com/rpc/2.0/nlp/v1/sentiment_classify HTTP header Content-Type 用 application/json access_token 填入你的 access_token charset 填入 UTF-8 HTTP body 帶一個 json： 123{ &quot;text&quot;: &quot;你想要分析的文字，最多能帶2048個字元&quot; } 以 curl 為例 1curl -i -X POST -H &quot;Content-Type: application/json&quot; -d '{&quot;text&quot; : &quot;剛剛那家餐廳蠻好吃的，我們下次再約個時間來吃第二次吧！&quot;}' &quot;https://aip.baidubce.com/rpc/2.0/nlp/v1/sentiment_classify?charset=UTF-8&amp;access_token=your_access_token&quot; 就能收到情緒分析啦 123456789101112{ &quot;log_id&quot;: 4703034185884062249, &quot;text&quot;: &quot;剛剛那家餐廳蠻好吃的，我們下次再約個時間來吃第二次吧！&quot;, &quot;items&quot;: [ { &quot;positive_prob&quot;: 0.566052, &quot;confidence&quot;: 0.0356713, &quot;negative_prob&quot;: 0.433948, &quot;sentiment&quot;: 2 } ] } 參考 https://ai.baidu.com/docs#/NLP-Apply-API/955c17f6","link":"/chinese-sentiment-analysis-using-baidu-aip-service/"},{"title":"來為你的 Line bot 加上一個圖文選單吧！","text":"拖了好久，終於有時間幫 彈幕教室 chatbot 裝個圖文選單啦，照著 官方教學 做其實就沒問題囉，但還是把實作的過程紀錄下來備忘。 順便打個廣告 https://github.com/danmu-classroom/danmu-classroom-screen，彈幕教室客戶端，下載即用免安裝，可以透過 Line 發送彈幕到螢幕上，歡迎來玩看看喔。 我的 rich menu 長這樣 我們以 Messaging API 建立圖文選單時，需要能發送 http request 的工具， curl / Postman / Insomnia 選其中一個順手的用就好，待會的例子會附上 Insomnia 的畫面截圖。 摘要前置任務：取得 channel access token 建立 rich menu (文件) 上傳圖片 (文件) 設定預設的 rich menu (文件) 就這樣，懶得看文件的有福了，看我這篇就好。 取得 channel access token登入 Line Developers，進入你的 chat bot 管理介面，Channel setting 頁籤滑到 Messaging settings，把 token 複製起來等等會用到。 建立 rich menuAPI 是 POST https://api.line.me/v2/bot/richmenu Auth 方法選擇 Bearer Token TOKEN 處填入你的 channel access token，Request body 選 JSON 接著 Request body 填入下面的 JSON： size 有兩種能選，2500 * 843 或是 2500 * 1686 select 設成 true 的話會預設展開圖文選單 chatBarText 的文字會顯示在 areas[0].bonuds 定義按鈕區域，areas[0].action 定義按下去的行為 特別注意圖文選單的左上角座標 x, y = 0, 0 ，並非以左下角為原點 送出 request 後，會回傳一個 richMenuId 等等會用到複製起來。 上傳圖片API 是 POST https://api.line.me/v2/bot/richmenu/{richMenuId}/content richMenuId 填剛剛拿到的 richMenuId 只支援 .jpg or .png Auth 一樣是 Bearer Token，Body 這次選 File，點 Choose File 選擇圖片，跳出詢問更改 Header 的提示，點 Yes，然後送出 request 設定預設的 rich menuAPI 是 POST https://api.line.me/v2/bot/user/all/richmenu/{richMenuId} richMenuId 一樣，Auth 也一樣是 Bearer Token，這次 Body 留空就好，送出後就完成啦。 有 rich menu 的 chat bot 感覺更厲害了呢！","link":"/create-a-rich-menu-for-your-line-bot/"},{"title":"部署你的 rails 應用程式至 Heroku","text":"Heroku 是一個 platform as a service 平台，可以部署專案在此，使用上非常方便的，當然方便的代價是價格，他的單位計算資源價格會高於 AWS。 安裝 heroku-cli見 https://devcenter.heroku.com/articles/heroku-cli 12# 將 heroku 加入 brew 的來源brew tap heroku/brew &amp;&amp; brew install heroku 登入 Heroku 帳號 1heroku login 一般我們使用 git 來部署應用程式至 Heroku，在下個步驟前，確認你的專案已經使用 git 做版本控制了。 設定 git remote新建一個專案叫 app_name: 1heroku create app_name 已經在Heroku 上建立專案了則使用： 12# set git remote heroku to https://git.heroku.com/app_name.githeroku git:remote -a app_name 設定 Rails app使用 Postgres 作為資料庫，將下列這行加入 Gemfile : 12# Gemfilegem 'pg' 設定資料庫連線資訊： 12# config/database.ymlproduction: url: &lt;%= ENV['DATABASE_URL'] %&gt; 在 config/environments/production.rb 中對 assets 與 log 做設定 12# config/environments/production.rbconfig.public_file_server.enabled = ENV['RAILS_SERVE_STATIC_FILES'].present?if ENV[&quot;RAILS_LOG_TO_STDOUT&quot;].present? logger = ActiveSupport::Logger.new(STDOUT) logger.formatter = config.log_formatter config.logger = ActiveSupport::TaggedLogging.new(logger)end 指定使用的 Ruby 版本，新增檔案 .ruby-version填入： 12# .ruby-versionruby-2.6.0 在專案的根目錄下建立一個 Procfile 檔案 ($ touch Procfile)，並填入以下內容： 123# Procfileweb: bundle exec puma -C config/puma.rbsidekid: bundle exec sidekiq -C config/sidekiq.yml 設定 Heroku在 Heroku 管理介面 &gt; app_name &gt; Settings &gt; Reveal Config Vars，DATABASE_URL 這個環境變數，填入的是你的 production database 的連線位址與帳號密碼，Heroku 會預設幫你填入他提供的 Postgres 資料庫。 接著 Add buildpack，加入 heroku/nodejs buildpack 並放在 heroku/ruby 之前： 有需要 node_modules 者才需要做這個步驟 部署在部署前 git commit 把要部署的專案放置在 master 分支下，然後： 12# push master 分支到 heroku remotegit push heroku master 有新的 database migrations 時執行： 12# heroku run + 要運行的指令，這次要做 database migrateheroku run rails db:migrate","link":"/deploy-your-rails-app-to-heroku/"},{"title":"Homebrew — mac 必裝的套件管理","text":"就像 Ubuntu 上的 apt，可以透過命令列安裝套件，更新套件。 官網 https://brew.sh/，Github https://github.com/Homebrew/brew/ 安裝進 https://brew.sh/ 看其安裝說明，在終端機輸入： 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 常用指令1234567891011121314151617181920212223242526272829303132# 查看套件資訊brew info something# 安裝套件brew install something# 更新套件brew update# 解除安裝套件brew uninstall something# 重新安裝套件brew reinstall something# 把套件連結至 binbrew link something# 檢查 brew 有沒有缺少什麼brew doctor# 升級 brewbrew upgrade# 查看可透過 brew 啟用的 servicesbrew services list# 啟用 servicebrew services start something# 停用 servicebrew services stop something Brew Caskbrew 除了套件也可以安裝應用程式，以 atom 為例： 1brew cask install atom Cakebrew : Brew GUICakebrew (https://github.com/brunophilipe/Cakebrew) 是一款 brew 的 GUI，我們可以透過熟悉的應用程式介面來安裝套件。 透過 brew 來安裝 cakebrew： 1brew cask install cakebrew","link":"/homebrew-best-package-manager-on-mac/"},{"title":"在 Mac 上安裝 Ruby","text":"Mac OS X 內建的 Ruby 版本並非最新版，只安裝了維持系統運行，最低需求版本的 Ruby，所以要安裝最新版本的 Ruby 就得額外安裝。 Install RubyVia Homebrewbrew install ruby Via Ruby Version Manager (RVM)如果開發環境有安裝多個版本的 Ruby 的需求，就使用 RVM 來安裝與管理 Ruby 吧，可以透過 RVM 自由切換使用的 Ruby 版本與 Gemset，保持開發環境的乾淨。 詳情見 https://rvm.io/ 12345# Install GPG keys:gpg2 --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB# Install RVM:curl -sSL https://get.rvm.io | bash -s stable 12345678910111213# 常用指令# 列出所有版本的 Rubyrvm list known# 安裝 Ruby 2.6rvm install 2.6# 切換 Ruby 版本成 2.6rvm use 2.6# 設定 Ruby 預設版本為 2.6rvm --default use 2.6 GemGem 就是 Ruby 開發者共享的函式庫，Rails 也是 Ruby 的一個 Gem， 見 https://rubygems.org 查看這些 Gems。 設定安裝 Gem 時不要安裝文檔，於 ~/.gemrc 加上這行 : 12# .gemrcgem: --no-rdoc --no-ri 使用 gemset 讓開發環境可以隔離不互相干擾，每個 RVM 安裝的 Ruby 版本預設使用 default gemset，我們也可以自己建立 gemset project 12345678# 建立 gemset projectrvm gemset create project# 切換成 gemset projectrvm use 2.6@project# 切回預設的 gemsetrvm use 2.6@default","link":"/install-ruby-on-mac/"},{"title":"Network graphing in JavaScript - force-graph","text":"分析網路關係，並將資料視覺化，最常見的就是 network graph。 常見套件 https://github.com/vasturiano/3d-force-graph 本文主角，支援 3D 與圖互動。 https://github.com/vasturiano/force-graph 本文主角，支援與圖互動。 https://github.com/jacomyal/sigma.js 文檔寫在程式碼與範例中，需要參考它的範例原始碼。將圖展開可以使用它提供的 plugin forceAtlas2，與圖互動需要自己 coding 擴充。 https://github.com/cytoscape/cytoscape.js 提供許多範例可以參考。 https://github.com/almende/vis 不只做 network graph，可上官網參考範例。 https://github.com/davidpiegza/Graph-Visualization 支援 3D，文檔並不齊全，需要參考它的範例原始碼 最易用的套件force-graph 當之無愧，因為它幫我們跳過了底層 canvas / three 繁瑣的設置，也預設了展開圖中各點的演算法 DAG ，開發者只需要指定要畫在哪個 html dom 上，輸入 data 就能見到一張漂亮的圖，若是要客製化某些功能，也能透過其提供的 API 設置顏色事件等等。 詳細的 API 請見： https://github.com/vasturiano/force-graphhttps://github.com/vasturiano/3d-force-graph 範例https://codepen.io/aaron1995/pen/VNJZZE","link":"/network-graphing-in-javascript-force-graph/"},{"title":"Port 被佔用了？","text":"有看過即刻救援嗎？我們只需要像史上最強老爸一樣，即可解決此問題。 這邊使用 port 3000 當做例子 找到它1234# 列出 port 3000 的行程lsof -i:3000# 列出 port 3000 行程的 pidlsof -t -i:3000 幹掉它1234# 透過 pid 清除行程kill $(lsof -t -i:3000)# or 使用 -9 optionkill -9 $(lsof -t -i:3000) 使用 -9 option 的差異在於作業系統發送的中斷訊號不同。","link":"/port-is-already-in-used/"},{"title":"Heroku 上執行 Rails app 的定時任務（Scheduled Task）","text":"一般 Rails app 的定時任務是把 ActiveJob 包成一個 rake task 並透過 crontab 執行。這種架構的適合用在分鐘級別以上的定時任務。 但是 Heroku 並沒有提供 crontab 指令，在 Heroku 上運行定時任務必須用到一個 addon：Heroku Scheduler Heroku Scheduler 到 Heroku App dashboard Resouces 頁籤 新增一個 Heroku Scheduler 的 addon Add new job 輸入指令 ，並設定執行頻率。這邊以每月 25 號寄送生日通知信為例 ( rails mail:birth_notification )，我設定頻率為每天，它每天都會檢查今天是不是 25 日，是則執行後面的指令 12# every months 25th do this rake taskif [ &quot;$(date +%d)&quot; = 25 ]; then rails mail:birth_notification; fi Heroku Scheduler 最小只提供間距為 10 分鐘級別的定時任務，若要更精細，只能使用應用層級的定時排程了例如: https://github.com/mperham/sidekiq/wiki/Scheduled-Jobs https://github.com/moove-it/sidekiq-scheduler https://github.com/ondrejbartas/sidekiq-cron","link":"/running-rails-scheduled-task-on-heroku/"},{"title":"Rails 的 sidekiq 設置筆記","text":"Sidekiq 是一個能夠並發處理 Ruby 任務的套件，大致上的運作方法是：將任務 push 至 redis 的 queue 中，sidekiq 的 workers 再到 queue 一個個 pop 任務出來運算。 安裝12# Gemfilegem 'sidekiq' 1bundle install 設置Sidekiq見 https://github.com/mperham/sidekiq/wiki/Advanced-Options。 ActiveJob 使用的 redis queue 名稱預設為 default，ActionMailer 使用的 redis queue 名稱預設為 mailers。 concurrency 參數需要小於或等於 config/database.yml中的 pool 值。 12345# config/sidekiq.yml:concurrency: 16:queues: — default — mailers ActiveJob 使用 Sidekiq見 https://github.com/mperham/sidekiq/wiki/Active-Job，在 environments/development.rb 與 environments/production.rb 中填入： 1config.active_job.queue_adapter = :sidekiq 設置 Sidekiq 管理介面Sidekiq 提供了一個管理介面，見 https://github.com/mperham/sidekiq/wiki/Monitoring，要將此管理介面放入既有的 Rails 專案，只需要在 config/routes.rb中加入： 123# config/routes.rbrequire 'sidekiq/web'mount Sidekiq::Web =&gt; '/sidekiq' 為 sidekiq 管理介面做權限控管，只讓 admin 可以查看管理介面，使用 devise + cancancan做例子： 12345# config/routes.rbrequire 'sidekiq/web'authenticate :user, -&gt;(u) { Ability.new(u).can? :manage, :admin } do mount Sidekiq::Web =&gt; 'admin/sidekiq'end authenticate :user, -&gt;(u) { condition } 這個式子中的 condition是 true 即可通過驗證。 執行1sidekiq -C config/sidekiq.yml","link":"/setup-sidekiq-on-rails/"},{"title":"Developer 最常用的 Proxy 設定","text":"本文整理了系統環境變數、 git、curl、wget、npm、bundler、nuget、brew、apt 與 chocolatey 等多種下載工具的 proxy 設定。 前言當公司有做網路控管時，對外的網路請求通常需要經由 proxy server 轉送，對內或 localhost 的可以不需要，要也沒關係就是要繞一圈比較慢。 接下來我們將用 http://proxy.company.com:80 這個 proxy server 為例，示範如何設置其他工具的 proxy。 系統環境變數 environmentWindows控制台 &gt; 系統及安全性 &gt; 系統 &gt; 進階系統設定 &gt; 進階 &gt; 環境變數 &gt; 系統變數 &gt; 新增 變數 值 PROXY http://proxy.company.com:80 HTTP_PROXY http://proxy.company.com:80 HTTPS_PROXY http://proxy.company.com:80 ALL_PROXY http://proxy.company.com:80 NO_PROXY localhost,127.0.0.1,.company.com proxy http://proxy.company.com:80 http_proxy http://proxy.company.com:80 https_proxy http://proxy.company.com:80 all_proxy http://proxy.company.com:80 no_proxy localhost,127.0.0.1,.company.com Ubuntu在 ~/.profile 中新增 123456789101112PROXY=&quot;http://proxy.company.com:80&quot;NO_PROXY=&quot;localhost,127.0.0.1,.company.com&quot;export PROXY=$PROXYexport HTTP_PROXY=$PROXYexport HTTPS_PROXY=$PROXYexport ALL_PROXY=$PROXYexport NO_PROXY=$NO_PROXYexport proxy=$PROXYexport http_proxy=$PROXYexport https_proxy=$PROXYexport all_proxy=$PROXYexport no_proxy=$NO_PROXY 確保你使用的 shell，如 zsh，會在登入後 source ~/.profile git下指令 1git config --global http.proxy http://proxy.company.com:80 或是編輯 .gitconfig，位於 Linux : ~/.gitconfig Windows : %USERPROFILE%\\.gitconfig 填入 12[http] proxy = http://proxy.company.com:80 curl建議使用環境變數設定 curl\b\b，它預設會套用環境變數，見官方文件 或是編輯 .curlrc，位於 Windows %APPDATA%\\_curlrc %USERPROFILE%\\Application Data\\_curlrc Linux ~/.curlrc 填入 123https_proxy=http://proxy.company.com:80http_proxy=http://proxy.company.com:80proxy=http://proxy.company.com:80 wget建議使用環境變數設定 wget，它預設會套用環境變數，見官方文件 或是編輯 .wgetrc，填入 1234use_proxy = onhttps_proxy = http://proxy.company.com:80http_proxy = http://proxy.company.com:80no_proxy = localhost,127.0.0.1,.company.com npm透過指令 12345npm config set https-proxy http://proxy.company.com:80npm config set proxy http://proxy.company.com:80npm config set noproxy localhost,127.0.0.1,.company.comnpm config set always-auth truenpm config set strict-ssl false 或是編輯 .npmrc，位於 Windows : %USERPROFILE%\\.npmrc Linux : ~/.npmrc bundler建議使用環境變數設定 bundler，它預設會套用環境變數，見官方文件 或是編輯 gemrc，設定檔位於 ~/.gemrc，填入 12---http_proxy: http://proxy.company.com:80 nuget建議使用環境變數設定 nuget，它預設會套用環境變數，見官方文件 透過命令列 or 編輯設定檔 12nuget config -set http_proxy=http://proxy.company.com:80nuget config -set no_proxy=localhost,127.0.0.1,.company.com 設定檔位於 Windows %APPDATA%\\NuGet\\NuGet.Config %USERPROFILE%\\.nuget Linux ~/.nuget 填入 123456&lt;configuration&gt; &lt;config&gt; &lt;add key=&quot;http_proxy&quot; value=&quot;http://proxy.company.com:80&quot; /&gt; &lt;add key=&quot;no_proxy&quot; value=&quot;localhost,127.0.0.1,.company.com&quot; /&gt; &lt;/config&gt;&lt;/configuration&gt; brew使用 curl 來取得軟體，因此需要設定的是 curl apt建議使用環境變數設定 apt，它預設會套用環境變數，見官方文件 如需編輯設定檔，可至 /etc/apt/apt.conf，填入 1Acquire::http::proxy &quot;http://proxy.company.com:80&quot;; 注意！apt 會以環境變數 http_proxy 設定優先，所以當你有設定 http_proxy 後，apt.conf 內的設定就會被無視。 chocolatey建議使用環境變數設定 chocolatey，它預設會套用環境變數，見官方文件 透過指令設定 proxy 12choco config set proxy http://proxy.company.com:80choco config set proxyBypassList &quot;'localhost,127.0.0.1,.company.com'&quot;","link":"/the-most-common-proxy-settings-for-developers/"},{"title":"在 SendGrid 上驗證你的網域","text":"前言以 SendGrid 寄送 email 時，若無進行網域驗證，有些信箱會在寄件者後面帶上一個後綴提示使用者，這封 email 實際的寄送網域為何，因此會多一個透過 sendgrid.me的後綴 ，如 這表示寄件者與實際寄送 email 的網域不同，見 https://support.google.com/mail/answer/1311182 移除警示要如何將這個警示後綴拿掉呢？驗證網域，常見的方法有設定，見 https://support.google.com/mail/answer/180707 DKIM SPF 而 SendGrid 有提供第三種選擇，設定 CNAME，本篇將依照 SendGrid 的官方文件將設置步驟記錄下來 在 SendGrid 上提出 domain 驗證的請求登入 SendGrid，我是透過 Heroku SSO 登入。 選擇側邊欄的 Setting &gt; Sender Authentication 選擇你 domain 的 DNS host 在哪，例如我的 caten-church.org host 在 CloudFlare 上，我就選 CloudFlare 接著填入你的網域 新增 DNS 的 CNAME這時 SendGrid 會跳出 3 組 CNAME 的 name 與 value 將其加入你的 DNS record 中 通過 SendGrid 的驗證接著回到 SendGrid 按下 Verify 驗證成功！ 只要驗證完成後，收件人收到 SendGrid 替你送出的 email 就不會有 via sendgrid.net 等警示在寄件人後面了","link":"/authenticate-your-domain-on-sendgrid/"},{"title":"在 Angular 中請這樣用 RxJS","text":"本篇只是閱讀原文後的譯文原文出處： https://blog.strongbrew.io/rxjs-best-practices-in-angular Stream 加上 $ suffix這是一個由 Cycle.js 開始的慣例 Angular 官方也建議，在 Observable 型別的變數後面加上 $ ，這樣一看就知道是不是 observable 12345&lt;!-- bad --&gt;&lt;li *ngFor=&quot;let hero of heroes | async&quot; /&gt;&lt;!-- good --&gt;&lt;li *ngFor=&quot;let hero of heroes$ | async&quot; /&gt; 使用 pure functionspure functions 的定義 functions 不會改動任何的外部狀態 functions 不依賴 input 以外的 outside state，一樣的 input 會得到一樣的 output 補充資料 此為 functional programming 的基礎，當我們在 reactive flow 時，遵循這個原則可以讓我們不會被 outside state 干擾，更專注於 reactive 的行為上 記得 unsubscribe()不要造成 memory leak 常用 3 招 unsubscribe 所有的 subscriptions 使用 array 123456789101112import { Subscription } from 'rxjs';class AppComponent implements OnDestroy { private subscriptions = Subscription[]; this.subscriptions.push(observable1$.subscribe()); this.subscriptions.push(observable2$.subscribe()); this.subscriptions.push(observable3$.subscribe()); ngOnDestroy() { this.subscriptions.forEach(s =&gt; s.unsubscribe()); }} 使用 takeUntil() operator 1234567891011class AppComponent implements OnDestroy { private destroy$ = new Subject(); this.observable1$.pipe(takeUntil(this.destroy$)).subscribe()); this.observable2$.pipe(takeUntil(this.destroy$)).subscribe()); this.observable3$.pipe(takeUntil(this.destroy$)).subscribe()); ngOnDestroy() { this.destroy$.next(true); }} 使用 https://github.com/wardbell/subsink 1234567891011class AppComponent implements OnDestroy { private subs = new SubSink(); this.subs.sink = observable1$.subscribe(); this.subs.sink = observable2$.subscribe(); this.subs.sink = observable3$.subscribe(); ngOnDestroy() { this.subs.unsubscribe(); }} 不要重複訂閱12345678// badngOnInit() { this.loadData()}loadData() { this.observable$.subscribe(result =&gt; this.result = result);} loadData() 如果會被重複使用到就造成重複訂閱了 1234// goodngOnInit() { this.observable$.subscribe(result =&gt; this.result = result);} 不要 nested subscribes12345678910// badclass AppComponent { user: User; constructor(private route: ActivatedRoute, private userService: UserService){ this.route.params.pipe(map(v =&gt; v.id)) .subscribe(id =&gt; this.userService.fetchById(id) .subscribe(user =&gt; this.user = user)); }} 1234567891011// goodclass AppComponent { user: User; constructor(private route: ActivatedRoute, private userService: UserService){ this.route.params.pipe( map(v =&gt; v.id), switchMap(id =&gt; this.userService.fetchById(id)) ) .subscribe(user =&gt; this.user = user); }} 再來一個 Akita 的例子 123456789// badthis.userService.query.username$.subscribe( username =&gt; this.userService.getUserProfile(username).subscribe());// goodthis.userService.query.username$.pipe( mergeMap(username =&gt; this.userService.getUserProfile(username))).subscribe(); 憋不住寫出 nested subscribes，請用 switchMap, concatMap, mergeMap, exhaustMap 重構這坨糙 code 可以用 async pipeline 就不要自己 subscribe好處 自動幫你 on init subscribe 自動幫你 on destroy unsubscribe code 變少了 更好看 12345678910@Component({ template: `&lt;user-detail [user]=&quot;user$ | async&quot;&gt;&lt;/user-detail&gt;`})class AppComponent { user$ = this.route.params.pipe( map(v =&gt; v.id), switchMap(id =&gt; this.userService.fetchById(id)) ); constructor(private route: ActivatedRoute,private userService: UserService) {}} 不要從父組件傳 stream 給子組件父組件訂閱 stream 後，直接傳值給子組件 這樣一來就不用每個子組件都訂閱一次，使用更少記憶體，且邏輯也更清晰 12345678910111213141516171819202122// bad// app.component.ts@Component({ selector: 'app', template: `&lt;user-detail [user$]=&quot;user$&quot;&gt;&lt;/user-detail&gt;`})class AppComponent { users$ = this.http.get('https://api.example.com/users');}// user-detail.component.ts@Component({ selector: 'user-detail', template: ``})class UserDetailComponent implements OnInit { @Input() user$: Observable&lt;User&gt;; user: User; ngOnInit(){ this.user$.subscribe(user =&gt; this.user = user); }} 1234567891011121314151617181920212223// good// app.component.ts@Component({ selector: 'app', template: `&lt;user-detail [user]=&quot;user$ | async&quot;&gt;&lt;/user-detail&gt;`})class AppComponent implements OnInit { users$: Observable&lt;User[]&gt; = this.http.get(...); user: User; ngOnInit(){ this.users$ = this.http.get('https://api.example.com/users'); } ...}// user-detail.component.ts@Component({ selector: 'user-detail', template: ``})class UserDetailComponent { @Input() user: User;} 不要從 component 傳 stream 給 service原本一個 stream 從 service 出發，到 component 被 subscribe services &gt; component 這個時候你又把 stream 作為參數傳回 service，如果這個 service 又被其他 component 使用 services &gt; component &gt; service &gt; components &gt; … 此時這個 Stream 的生命週期就沒完沒了了 12345678910111213// bad// app.component.tsclass AppComponent { users$ = this.http.get('https://api.example.com/users'); filteredUsers$ = this.fooService.filterUsers(this.users$);}// foo.service.tsclass FooService { filterUsers(users$: Observable&lt;User[]&gt;): Observable&lt;User[]&gt; { return users$.pipe(map(users =&gt; users.filter(user =&gt; user.age &gt;= 18)) }} 正確做法應該是 12345678910111213// good// app.component.tsclass AppComponent { users$ = this.http.get('https://api.example.com/users') filteredUsers$ = this.users$.pipe(switchMap(users =&gt; this.fooService.filterUsers(users)));}// foo.service.tsclass FooService { filterUsers(users: User[]): User[] { return users.filter(user =&gt; user.age &gt;= 18); }} 少用 BehaviorSubject 與 Akita 的 getValue()當你使用 getValue() 的瞬間，你就已經 not thinking reactive 了 保持 Clean code pipe 內的 operators 對齊好 12345foo$.pipe( map(...) filter(...) tap(...)) stream 邏輯太複雜的時候抽到另一個 stream 中，可以用 subject$.next() 1234567891011121314151617181920212223// Listening on save button clickthis.subscriptions.push( this.onSaveBtnClick$.subscribe(data =&gt; { const user: User = { ...data }; !user.id ? this.createRecord$.next(user) : this.updateRecord$.next(user); }));// Listening on record createthis.subscriptions.push( this.createRecord$.pipe( mergeMap(user =&gt; this.userService.create(user)) ) .subscribe(_ =&gt; console.info('user created')));// Listening on record updatethis.subscriptions.push( this.updateRecord$.pipe( mergeMap(user =&gt; this.userService.update(user.id, user)) ) .subscribe(_ =&gt; console.info('user created'))); operator 中的邏輯太複雜的時候，可以抽到 private method 中 單行能解決，就不用 {} 1234567// badobservable$.subscribe(result =&gt; { console.log(result)})// goodobservable$.subscribe(result =&gt; console.log(result))","link":"/using-rxjs-this-way-in-angular/"},{"title":"Win10 WSL combo : Terminus + Ubuntu + Oh My Zsh + Powerlevel10k","text":"簡介想在 Windows 上使用潮潮的 Linux 命令列嗎？ 本篇將教你如何使用 WSL Ubuntu + Terminus + Oh My Zsh + Powerlevel10k 連續技，達到爽度十足的開發環境 安裝 WSL直接透過 Microsoft Store 安裝 Ubuntu 18.04 LTS，見此文件 若公司有擋 Microsoft Store 則下載 distros 版的 Linux 安裝檔 Ubuntu 18.04，見此文件 若公司有擋預設安裝路徑，則將剛下載的 CanonicalGroupLimited.Ubuntu18.04onWindows_1804.2018.817.Appx 改成 Ubuntu 18.04.zip，解壓縮至 C:\\WSL\\Ubuntu 18.04，進入此資料夾執行 .exe 檔 ，見此文件 安裝 TerminusTerminus 是款跨平台的命令列工具，本次會選擇這個工具的原因有二 它附帶了字型與顏色，還有著漂亮的 GUI 設定介面，非常適合懶人直接安裝使用 我的 Windows 版本尚未升級到 Win 10 1903，所以不能使用 Windows Terminal 到 releases 選擇 setup.exe 下載並執行 安裝 Oh My Zsh用 Terminus 打開 Cmd 輸入指令 1wsl 進入 Ubuntu 18.04 subsystem 後用 curl 或 wget 下載 Oh My Zsh 並執行 curl 1sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; wget 1sh -c &quot;$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; 安裝 Powerlevel10kPowerlevel10k 原是 fork 自 powerlevel9k，比起 9k 的穩定，10k 更著重於效能與新功能，所有的程式碼都已完全重寫與 9k 不同了。 10k 的官網上也有與 9k 的速度比較的影片，我自己感覺 10k 的確是比 9k 的反應更加靈敏快速。 一樣是在 subsystem 內操作 用 Oh My Zsh 安裝 Powerlevel10k 1git clone --depth=1 https://github.com/romkatv/powerlevel10k.git $ZSH_CUSTOM/themes/powerlevel10k 打開 ~/.zshrc. 將 ZSH_THEME 設定成 powerlevel10k 1ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot; 重新進入 wsl 讓 zsh 讀取剛剛的設定 接著透過互動式命令列來設定 powerlevel10k 1p10k configure 設定字型與配色到 ryanoasis/nerd-fonts 下載 Sauce Code Pro Nerd Font Complete Mono Windows Compatible.ttf 並安裝 回到 Windows，打開 Terminus &gt; Setting &gt; Appearance 設定 Terminus 的字型與配色 Font: SauceCodePro Nerd Font Color Scheme: OneHalfDark 這樣就大功告成啦~","link":"/win10-wsl-combo-terminus-ubuntu-oh-my-zsh-powerlevel10k/"},{"title":"Expression Index in RDBMS","text":"What is the expression index? According to the description from Wikipedia An expression index, also known as a function based index, is a database index that is built on a generic expression, rather than one or more columns. This allows indexes to be defined for common query conditions that depend on data in a table, but are not actually stored in that table. When you query on something that is computed from other columns frequently and want to speed it up, you will need this. I will use PostgreSQL as an example in this article because it is my favorite database. I have a profiles table which has a name column to store the name of users, and I already created an index for the name column Then I want to select some profiles where lowercase name is xxx, so the query looks like below: 1SELECT * FROM profiles WHERE lower(name) = 'aaron yang'; Create IndexIt is very simple to create an index, we need to use ( and ) to wrap the expression 1CREATE INDEX index_profiles_on_lower_name ON profiles (lower(name)); After that we created an expression index, with condition is (lower((name)::text)) Explain QueryTo make sure the index has been used. EXPLAIN query before the expression index created 1EXPLAIN SELECT * FROM profiles WHERE lower(name) = 'aaron yang'; As you may have noticed Seq Scan on profiles, it is a full table scan Let’s try again, the same EXPLAIN query after expression index created 1EXPLAIN SELECT * FROM profiles WHERE lower(name) = 'aaron yang'; Yeah, the query is using the expression index. If your query still using the Seq Scan, that is because the rows of the table are too small, Postgres estimate seq scan will faster than using an index, see more here or here Databases CompatibilityIn 2020, most of the relation database supported this feature, but name it differently: expression index, function index Some of the databases unsupported this feature, but there is a workaround for them. Supported ✅you can create an expression index directly. Database Feature name Supported Version References PostgreSQL Indexes on Expressions 9.5.0 and the above docs SQLite Indexes on Expressions 3.9.0 and the above docs Oracle Function-Based Indexes 8i and the above docs MySQL Functional Key Parts 8.0.13 and the above docs The feature name of databases is interesting, do you see the pattern? it shows PostgreSQL and SQLite are closer, and Oracle and MySQL are closer. Unsupported ❌but you can work around by creating a computed column then create an index on it. |Database|Feature name|Supported Version||References||—|—|—|—||MariaDB|Indexes on Generated columns|10.2.3 and above support index on virtual column|docs||SQL Server|Indexes on Computed column|still can’t index on virtual but persisted column|docs| Hello SQL Server? References https://www.postgresql.org/docs/current/indexes-expressional.html https://www.sqlite.org/expridx.html https://docs.oracle.com/en/database/oracle/oracle-database/20/adfns/indexes.html#GUID-44AD4D28-A056-4977-B2F7-AC1BC50EDC87 https://dev.mysql.com/doc/refman/8.0/en/create-index.html#create-index-functional-key-parts https://mariadb.com/kb/en/generated-columns/ https://docs.microsoft.com/zh-tw/sql/relational-databases/indexes/indexes-on-computed-columns?view=sql-server-ver15","link":"/expression-index-in-rdbms/"},{"title":"從 Ruby 到 C# - operators","text":"Ruby 與 C# 的 operators 蠻相近的，應該說整個程式圈的 operators 都大概長那樣阿，嗯，沒錯，本篇完 欸，不是，我們快速帶過相同用法的 operators ，然後聊聊有差異的地方，這樣總行了吧 賦值 Assignment最基本的賦值 = 相同 12# Rubyfoo = &quot;bar&quot; 12// C#var foo = &quot;bar&quot;; 數學運算相關的 operators +=，-=，*=，/= 與 %= 皆相同，但 Ruby 還有多一個次方運算後賦值的 **= 12345678# Rubyfoo = 0 # =&gt; 0foo += 3 # foo = foo + 3 =&gt; 3foo -= 1 # foo = foo - 1 =&gt; 2foo *= 10 # foo = foo * 10 =&gt; 20foo /= 5 # foo = foo / 5 =&gt; 4foo %= 3 # foo = foo % 3 =&gt; 1foo **= 3 # foo = foo ** 3 =&gt; 1 1234567// C#var foo = 0; // =&gt; 0foo += 3; // foo = foo + 3 =&gt; 3foo -= 1; // foo = foo - 1 =&gt; 2foo *= 10; // foo = foo * 10 =&gt; 20foo /= 5; // foo = foo / 5 =&gt; 4foo %= 3; // foo = foo % 3 =&gt; 1 位元運算相關的 operators &amp;=，|= 與 ^= 也相同 12345# Rubyfoo = true # =&gt; truefoo &amp;= false # foo = foo &amp; false =&gt; falsefoo |= true # foo = foo | true =&gt; truefoo ^= true # foo = foo ^ true =&gt; false 12345// C#var foo = true; // =&gt; truefoo &amp;= false; // foo = foo &amp; false =&gt; falsefoo |= true; // foo = foo | true =&gt; truefoo ^= true; // foo = foo ^ true =&gt; false 邏輯運算相關的賦值 operators 就有點不同了，在 Ruby 中有 ||= 的用法，而 C# 可用 ??= 做到 123# Rubynumbers ||= []numbers &lt;&lt; 5 1234// C#List&lt;int&gt; numbers = null;numbers ??= new List&lt;int&gt;();numbers.Add(5); 在 Ruby 中，我們常以 ||= 為變數加上預設值，如果變數已經有值了就保持不動，若變數 undefined 或為 nil/false 才賦值 12# Ruby$redis ||= Redis.new # 如果沒有 redis client 就補建一個 比較少應用場景的 &amp;&amp;=，在 C# 中需要 override &amp;= 有人在 StackOverflow 上提問 ，為何 C# 沒有 ||= 與 &amp;&amp;=，我個人是不太認同此觀點，反正常用的 ||= 可以用 ??= 取代，影響不大，有興趣的網友可以加入這串討論 比較 ComparisonRuby 與 C# 在 ==，!=，&gt;，&gt;=，&lt;，&lt;= 與三元表示法 ? : 都相同 12345678910# Rubya = 10b = 50a == b # =&gt; falsea != b # =&gt; truea &gt; b # =&gt; falsea &gt;= b # =&gt; falsea &lt; b # =&gt; truea &lt;= b # =&gt; truea &lt; b ? 'yes' : 'no' # =&gt; 'yes' 12345678910// C#var a = 10;var b = 50;a == b // =&gt; falsea != b // =&gt; truea &gt; b // =&gt; falsea &gt;= b // =&gt; falsea &lt; b // =&gt; truea &lt;= b // =&gt; true(a &lt; b) ? 'yes' : 'no' // =&gt; 'yes' 不過 Ruby 中有一個特別的 operator &lt;=&gt;，它會回傳四種結果： -1 小於 0 等於 1 大於 nil 無法比較 123456# Rubya = 100a &lt;=&gt; 101 # -1a &lt;=&gt; 100 # 0a &lt;=&gt; 99 # 1a &lt;=&gt; '100' # nil 常常能在排序演算法中見到他的身影 補充，在 Ruby 中，我們可以在 lass 中 include Comparable module，為 class 擴充 7 種比較 methods &lt;，&lt;=，==，&gt;，&gt;=，between?與clamp 12# Rubyarray.sort{ |a, b| a &lt;=&gt; b } 算數 Arithmetic數學相關的 +，-，*，/ 與 % 皆相等 但 Ruby 有次方運算 **，沒有 ++ 與 --，見官方 FAQ 1234567number = 10number + 1 # =&gt; 11number - 1 # =&gt; 9number * 2 # =&gt; 20number / 3 # =&gt; 3number % 3 # =&gt; 1number ** 2 # =&gt; 100 12345678var number = 10;number + 1; // =&gt; 11number - 1; // =&gt; 9number * 2; // =&gt; 20number / 3; // =&gt; 3number % 3; // =&gt; 1number++; // 11number--; // 10 位元 Bitwise~，&lt;&lt;，&gt;&gt;，&amp;，|，^ 在 bitwise 上的用法完全相同 123456789# Rubya = 0b1100101b = 0b1010101~a # =&gt; 0b..10011010a &lt;&lt; 1 # =&gt; 0b11001010a &gt;&gt; 2 # =&gt; 0b11001a &amp; b # =&gt; 0b1000101a | b # =&gt; 0b1110101a ^ b # =&gt; 0b0110000 123456789// C#uint a = 0b1100101;uint b = 0b1010101;~a // =&gt; 0b..10011010a &lt;&lt; 1 // =&gt; 0b11001010a &gt;&gt; 2 // =&gt; 0b11001a &amp; b // =&gt; 0b1000101a | b // =&gt; 0b1110101a ^ b // =&gt; 0b0110000 在 Ruby 中某些 bitwise operators 會被 override 成其他用途，並非作為 bitwise operators 使用，如 1234567# Rubystring = 'foo'string &lt;&lt; 'bar' # =&gt; 'foobar'array = [1, 2, 3, 4]array &lt;&lt; 5 # =&gt; [1, 2, 3, 4, 5]array &amp; [4, 5, 6, 7] # =&gt; [4, 5] 使用前讀一下用的 class 的文件喔 邏輯布林 Logic boolean!，&amp;，|，^ 也是一樣的用法 12345# Ruby!true # =&gt; falsetrue &amp; false # =&gt; falsetrue | false # =&gt; truetrue ^ true # =&gt; false 12345// C#!true // =&gt; falsetrue &amp; false // =&gt; falsetrue | false // =&gt; truetrue ^ true // =&gt; false 它們在處理空 nil or null 上有些小差異 12# Ruby!nil # =&gt; true 12// C#!null // =&gt; error CS0023: The `!' operator cannot be applied tooperand of type `null' C# 中，型別為 bool 的變數無法存入 null 除非你使用 nullable 型別 bool? 宣告變數 另外還有兩個非常常用的 short-circuit evaluation operators &amp;&amp; 與 ||，使用方法也一樣喔 如何自訂 Operators由於 Ruby 與 C# 都是物件導向語言，以上這些 operators 會根據各類別不同的實作而有不同的效果 換句話說，這兩種語言都或多或少允許我們改寫類別的 operators，但他們還是有些許的差異 Ruby 中的 operators 其實就是個 method，見官方 FAQ 想要改變 operators 的行為則需要覆寫(override) 對應的 method 例如這題 Leetcode，用 override TreeNode 的 == 條件解決問題 12345678910111213# Rubyclass TreeNode def ==(tree) val == tree&amp;.val &amp;&amp; left == tree&amp;.left &amp;&amp; right == tree&amp;.right endend# @param {TreeNode} p# @param {TreeNode} q# @return {Boolean}def is_same_tree(p, q) p == qend 而 C# 將 operators 視為一種保留字 operator，我們需要透過多載(overload) operators 改變 operators 的行為 123456789101112131415// C#class TreeNode { public int val; public TreeNode left; public TreeNode right; public TreeNode(int x) { val = x; } public static bool operator ==(TreeNode l, TreeNode r) { return l.val == r.val &amp;&amp; l.left == r.left &amp;&amp; l.right == r.right; } public static bool operator !=(TreeNode l, TreeNode r) { return l.val != r.val || l.left != r.left || l.right != r.right; }} 官方建議大家在 overload operator 時，遵照這份指引，如上面的例子，overload == 請一併 overload != 統整共通點 =，+=，-=，*=，/=，%=，&amp;=，|=，^= ==，!=，&gt;，&gt;=，&lt;，&lt;=，? : +，-，*，/，% ~，&lt;&lt;，&gt;&gt;，&amp;，|，^ !，&amp;，|，^ &amp;&amp;，|| Ruby 多了 **．**= &amp;&amp;=，||= C# 多了 ++，-- ??= References https://en.wikibooks.org/wiki/Ruby_Programming/Syntax/Operators https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/ 系列文章 從 Ruby 到 C# 從 Ruby 到 C# - operators Condition Loop and Enumerator Base Type Collection Type Code Inclusion Class Interface Error handler Dev tools","link":"/from-ruby-to-c-sharp-operators/"},{"title":"從 Ruby 到 C#","text":"我是一名使用 Ruby 與 JavaScript 開發的程式設計師，我愛寫 Ruby，這個語言讓我體會到寫程式的樂趣 不過很可惜的目前服務的公司並沒有使用 Ruby 而是用 C# 作為後端的開發語言 欣慰的是 C# 與 JavaScript 看起來挺像的，希望我能將以前物件導向與 JavaScript 的開發經驗映射到 C# 上，快速掌握這門語言 也因此最近都在看微軟官方的 C# documentation 吐槽一下，比起 MDN 或 Ruby Doc，微軟的文件\b似乎沒那麼好看，，且尚未支援 Dash 與 DevDocs，只能透過瀏覽器到此查閱 我想撰寫一個系列，寫寫 C# 與 Ruby 的相似與相差之處，在嫌棄 C# 的過程中接納 C#，先把坑挖出來以後填： 從 Ruby 到 C# 從 Ruby 到 C# - operators Condition Loop and Enumerator Base Type Collection Type Code Inclusion Class Interface Error handler Dev tools 應該會寫得很主觀 XD，希望各位能夠不吝嗇的指出我的認知偏誤，謝謝各位。","link":"/from-ruby-to-c-sharp/"},{"title":"在 Mac 上 安裝 Docker for Mac","text":"Install\b目前 Docker for Mac 最方便的安裝方法就是使用 Homebrew Cask 安裝，打開 Terminal，輸入： 1brew cask install docker 安裝成功後打開 Docker.app 第一次打開時會需要你的作業系統密碼，安裝額外的套件，提供完整的功能 當安裝完成後，我們就能在右上角的工具欄看到鯨魚 🐳 icon 打開 Docker dashboard 看看，嗯，目前是空的，沒有任何的 container 在執行 Run接著執行一個 Redis 的 container 作為我們的 hello world 1docker run -d --name redis redis -d 背景執行此 container，--name redis 將此 container 命名為 redis Unable to find image 'redis:latest' locally 因此它自動從 Docker Hub pull 一個最新的 Redis image 下來，做成 container 執行 看看電腦上有哪些 docker images 吧 1docker image ls 現在電腦上有 Redis 的 image 了 接著檢查一下 有哪些 container 正在執行吧 1docker container ls 可以看到剛剛安裝的 Redis container 正在執行中 也可以從 Docker dashboard 的 GUI 確認 至此我們就 onboard Docker 囉 References https://docs.docker.com/docker-for-mac/install/ https://github.com/Homebrew/homebrew-cask/blob/master/Casks/docker.rb https://yeasy.gitbooks.io/docker_practice/install/mac.html","link":"/install-docker-on-mac/"},{"title":"代替 Illustrator 的免費繪圖軟體","text":"平面設計的首選 Adobe Illustrator 專業好用，但價格昂貴，Adobe 提供了 7 天的試用期，試用期過後每月需花費 1000 元訂閱，但有時候我們只是想簡單地處理一些圖形，並不需要使用到這麼專業且複雜的繪圖功能 😔 那或許你可以試試這些開源（或免費）的繪圖軟體，有機會替你省下每個月 1000 元的 Adobe Illustrator 喔！ Inkscape 官網: https://inkscape.org/ 原始碼: https://gitlab.com/inkscape/inkscape 支援平台: Linux, OS X, Windows 授權: GPL-2.0+ Linux 上可以透過 snap 安裝 1sudo snap install inkscape Mac 上可以透過 brew cask 安裝 1brew cask install inkscape Windows 上可以透過 chocolatey 安裝 1choco install inkscape LibreOffice - Draw 官網: https://www.libreoffice.org/ 原始碼 https://cgit.freedesktop.org/libreoffice 支援平台: Linux, OS X, Windows 授權: MPL-2.0 Linux 上可以透過 snap 安裝 1sudo snap install libreoffice Mac 上可以透過 brew cask 安裝 1brew cask install libreoffice Windows 上可以透過 chocolatey 安裝 1choco install libreoffice-fresh Vectr 官網: https://vectr.com/ 未開源但可免費使用 支援平台: Linux, OS X, Windows, 瀏覽器 授權: Proprietary 直接透過瀏覽器使用 Ｗeb App https://vectr.com/new Linux 上可以透過 snap 安裝 1sudo snap install vectr Mac 上可以透過 brew cask 安裝 1brew cask install vectr Boxy SVG 官網: https://boxy-svg.com/ 未開源，只在 Linux 上可免費使用 支援平台: Linux, OS X, Windows, 瀏覽器 授權: Proprietary Linux 上可以透過 snap 安裝 1sudo snap install boxy-svg macSVG 官網: https://macsvg.org/ 原始碼 https://github.com/dsward2/macSVG 支援平台: OS X 授權: MIT Mac 上可以透過 brew cask 安裝 1brew cask install macsvg SVG-Edit 官網: https://github.com/SVG-Edit/svgedit 原始碼: https://github.com/SVG-Edit/svgedit 支援平台: 瀏覽器 授權: MIT 直接透過瀏覽器使用 Ｗeb App https://svg-edit.github.io/svgedit/editor/svg-editor.html DRAW SVG 官網: http://www.drawsvg.org/ 未開源但免費 支援平台: 瀏覽器 授權: Proprietary 直接透過瀏覽器使用 Ｗeb App http://www.drawsvg.org/drawsvg.html Vector Paint 官網: https://vectorpaint.yaks.co.nz/ 未開源，作者已停止更新維護，但免費 支援平台: 瀏覽器 授權: Proprietary 直接透過瀏覽器使用 Ｗeb App https://vectorpaint.yaks.co.nz/ 點陣圖軟體但是也有支援向量Krita 官網: https://krita.org/ 原始碼: https://invent.kde.org/kde/krita 支援平台: Linux, OS X, Windows 授權: GPL-3.0 Linux 上可以透過 snap 安裝 1sudo snap install krita Mac 上可以透過 brew cask 安裝 1brew cask install krita Windows 上可以透過 chocolatey 安裝 1choco install krita GIMP 官網: https://www.gimp.org/ 原始碼: https://gitlab.gnome.org/GNOME/gimp 支援平台: Linux, OS X, Windows 授權: GPL-3.0 Linux 上可以透過 snap 安裝 1sudo snap install gimp Mac 上可以透過 brew cask 安裝 1brew cask install gimp Windows 上可以透過 chocolatey 安裝 1choco install gimp","link":"/free-or-open-source-illustrator-alternatives/"},{"title":"Make your PowerShell fancy by Windows Terminal and Oh My Posh","text":"GoalsFollow steps in this article, and the result will look like this StepsThere are only 6 steps to do Install Windows Terminal Install posh-git and oh-my-posh Install powerline font Config powershell profile Config Windows Terminal Settings Config VSCode Settings Maybe only need to takes 15 mins to set everything right. Install Windows TerminalFrom Windows Store Github Install posh-git and oh-my-poshOpen powershell and 12Install-Module posh-git -Scope CurrentUserInstall-Module oh-my-posh -Scope CurrentUser Install powerline fontSee https://github.com/ryanoasis/nerd-fonts Config powershell profileOpen powershell and 1code $PROFILE That will open Microsoft.PowerShell_profile.ps1, then we fill in this and save 123Import-Module posh-gitImport-Module oh-my-poshSet-PoshPrompt -Theme paradox Then powershell will import posh-git and oh-my-posh and set theme every time you start you powershell Config Windows Terminal SettingsOpen settings.json of Windows Terminal, add defaults section into profiles section, and assign colorScheme and fontFace you want 123456789101112131415161718192021222324252627{ &quot;profiles&quot;: { &quot;defaults&quot;: { // Put settings here that you want to apply to all profiles. &quot;colorScheme&quot;: &quot;One Half Dark&quot;, &quot;fontFace&quot;: &quot;SauceCodePro NF&quot; }, &quot;list&quot;: [ { // Make changes here to the powershell.exe profile. &quot;guid&quot;: &quot;...&quot;, &quot;name&quot;: &quot;Windows PowerShell&quot;, &quot;commandline&quot;: &quot;powershell.exe&quot;, &quot;hidden&quot;: false }, { // Make changes here to the cmd.exe profile. &quot;guid&quot;: &quot;...&quot;, &quot;name&quot;: &quot;命令提示字元&quot;, &quot;commandline&quot;: &quot;cmd.exe&quot;, &quot;hidden&quot;: false } ] },} Config VSCode SettingsOpen settings.json of vscode and add terminal.integrated.fontFamily 123{ &quot;terminal.integrated.fontFamily&quot;: &quot;SauceCodePro NF&quot;} References https://github.com/microsoft/terminal https://github.com/dahlbyk/posh-git https://github.com/JanDeDobbeleer/oh-my-posh/ https://github.com/ryanoasis/nerd-fonts https://zhuanlan.zhihu.com/p/354603010","link":"/make-your-powershell-fancy-by-windows-terminal-and-oh-my-posh/"},{"title":"為你的開源專案加些文件 讓它看起來很專業吧","text":"在 Github 上逛知名專案時，有沒有發現他們都有一個共同點: 文件豐富，有許多專案甚至會專門建立一個網站做 簡介 Demo API Documentation Wiki 論壇 看到這裡，你可能會說在小專案要求這些實在是太強人所難了吧。 其實啊，專案剛起步時，我們可以先從基礎的做起，例如這些被 check in 在各個知名 Git Repositories 中的文件 README.md CHANGELOG.md CODE_OF_CONDUCT.md CONTRIBUTING.md LICENSE.md 這些隨著程式碼擺放在 Repository 中的文件可以說是最基礎但又是最重要的文件，如果你的專案還沒有這些東西的話趕快來把它們加上去，可以讓你的專案瞬間變得很專業喔 XD 那我們要怎麼寫出好的文件呢? 從模仿開始吧 好的 README.md 可以看 https://www.makeareadme.com/ 好的 CHANGELOG.md 可以看 https://keepachangelog.com/en/1.0.0/ 好的 CODE_OF_CONDUCT.md 可以看 https://www.contributor-covenant.org/ 好的 CONTRIBUTING.md 可以看 https://github.com/github/docs/blob/main/CONTRIBUTING.md 或 https://docs.github.com/en/communities/setting-up-your-project-for-healthy-contributions/setting-guidelines-for-repository-contributors 好的 LICENSE.md 可以看 https://choosealicense.com/ 或 https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/creating-a-repository-on-github/licensing-a-repository 就醬，簡單吧😁 補充一個，Git Repository 的 commits 其實也是一種另類的文，所以，好的 Git Commits 可以看 https://www.conventionalcommits.org/en/v1.0.0/","link":"/make-your-open-source-projects-professional-with-good-documentation/"},{"title":"Unite Your Angular Coding Style With Teammates By Visual Studio Code &amp; ESLint &amp; Prettier","text":"BriefHello Visitor ~ Todays I will guide you to setup Visual Studio Code and ESLint and Prettier, let editor auto-format and auto-fix your code for you and your coworker or contributor, it will becomes your lifesaver, free your hands on fixing errors and align coding style with teammates. Let me read those documents, and organize things for you. StepsThere are only 3 steps for you, it is very easy to follow my steps to set everything up Setup Angular and ESLint Integrate Prettier and ESLint Setup Visual Studio Code Setup Angular and ESLintFor Angular project which started at Angular 12 1ng add @angular-eslint/schematics If your Angular project was started at Angular 11 or belows, you should read and follow this link Integrate Prettier and ESLint1234npm install --save-dev \\ prettier \\ eslint-config-prettier \\ eslint-plugin-prettier Create .prettierrc.json 1234{ &quot;singleQuote&quot;: true, &quot;jsxBracketSameLine&quot;: true} Update eslintrc.json 123456789101112{ &quot;overrides&quot;: [ { &quot;extends&quot;: [ &quot;airbnb-typescript&quot;, &quot;plugin:@angular-eslint/recommended&quot;, &quot;plugin:@angular-eslint/template/process-inline-templates&quot;, &quot;plugin:prettier/recommended&quot; // add this line ] } ]} Setup Visual Studio CodeCreate or update extensions.json 1234567{ &quot;recommendations&quot;: [ &quot;esbenp.prettier-vscode&quot;, // add this line &quot;dbaeumer.vscode-eslint&quot; // add this line ]} Create or update settings.json 123456789101112131415161718192021222324252627// add all these config{ &quot;files.eol&quot;: &quot;\\n&quot;, &quot;editor.formatOnSave&quot;: true, &quot;[json]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; }, &quot;[jsonc]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; }, &quot;[javascript]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; }, &quot;[typescript]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; }, &quot;[markdown]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; }, &quot;editor.codeActionsOnSave&quot;: { &quot;source.fixAll.eslint&quot;: true }, &quot;eslint.validate&quot;: [&quot;javascript&quot;, &quot;typescript&quot;, &quot;html&quot;], &quot;eslint.options&quot;: { &quot;extensions&quot;: [&quot;.js&quot;, &quot;.ts&quot;, &quot;.html&quot;] }} (Optional)Apply Airbnb’s TypeScript coding style to ESLint1npm install --save-dev eslint-config-airbnb-typescript Update eslintrc.json 1234567891011{ &quot;overrides&quot;: [ { &quot;extends&quot;: [ &quot;airbnb-typescript&quot;, // add this line &quot;plugin:@angular-eslint/recommended&quot;, &quot;plugin:@angular-eslint/template/process-inline-templates&quot; ] } ]} Referencesng + eslint https://github.com/angular-eslint/angular-eslint eslint + airbnb-typescript https://github.com/typescript-eslint/typescript-eslint/blob/master/docs/getting-started/linting/README.md#eslint-configs eslint + prettier https://github.com/typescript-eslint/typescript-eslint/blob/master/docs/getting-started/linting/README.md#usage-with-prettier https://github.com/prettier/eslint-config-prettier/blob/main/CHANGELOG.md#version-800-2021-02-21 https://github.com/prettier/eslint-plugin-prettier#recommended-configuration","link":"/unite-your-angular-coding-style-with-teammates-by-vscode-and-eslint-and-prettier/"},{"title":"Use Finite-state Machine to manage state","text":"IntroductionMain Elements: States: must be limited Events Transitions: when event 1 from state A to state B Actions: when state|event|transition changed then act action from https://en.wikipedia.org/wiki/Finite-state_machine, Fig. 3 Why We Need thisTo make sure complex things never gone off the rails Add constraints on states, throw errors to avoid bad things Help to sort out reaction when state changed Code is documentation Different with Flux-like State ManagementsFlux-like State Managements(Redux/MobX/NgRx) is a way to manage states by utilizing unidirectional data flows, it is often to using this kind of state management with functional programming. Redux lifecycle, from https://dev.to/radiumsharma06/abc-of-redux-5461, Fig. 1 It is easier to use FSM to manage state with object-oriented programming, but that did’t mean you can’t choose flux-like state management as your state management in object-oriented programming. Actually, I kind of perfer using flux-like state management in morden frontend framework(React/Vue/Angular), because of these framework encourage you to use functional programming/unidirectional data flows. Most of backend frameworks(Spring/Rails/Django/.NET) is develop by object-oriented programming languages, so using FSM to manage object state is totally reasonable. LibariesFor Ruby https://github.com/aasm/aasm For JavaScript or TypeScript https://github.com/davidkpiano/xstate For C# https://github.com/dotnet-state-machine/stateless References https://en.wikipedia.org/wiki/Finite-state_machine https://github.com/aasm/aasm https://github.com/davidkpiano/xstate https://github.com/dotnet-state-machine/stateless https://stackoverflow.com/a/54521035 https://medium.com/pm的生產力工具箱/如何有邏輯的釐清事物的狀態-f9fb59b15054 https://facebook.github.io/flux/docs/in-depth-overview/ https://dev.to/radiumsharma06/abc-of-redux-5461","link":"/use-finite-state-machine-to-manage-state/"}],"tags":[{"name":"rails","slug":"rails","link":"/tags/rails/"},{"name":"ruby","slug":"ruby","link":"/tags/ruby/"},{"name":"heroku","slug":"heroku","link":"/tags/heroku/"},{"name":"cloudflare","slug":"cloudflare","link":"/tags/cloudflare/"},{"name":"ssl","slug":"ssl","link":"/tags/ssl/"},{"name":"dns","slug":"dns","link":"/tags/dns/"},{"name":"https","slug":"https","link":"/tags/https/"},{"name":"free","slug":"free","link":"/tags/free/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"osx","slug":"osx","link":"/tags/osx/"},{"name":"brew","slug":"brew","link":"/tags/brew/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"hexo-theme","slug":"hexo-theme","link":"/tags/hexo-theme/"},{"name":"yilia","slug":"yilia","link":"/tags/yilia/"},{"name":"nvidia gpu driver","slug":"nvidia-gpu-driver","link":"/tags/nvidia-gpu-driver/"},{"name":"ubuntu","slug":"ubuntu","link":"/tags/ubuntu/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"tensorflow","slug":"tensorflow","link":"/tags/tensorflow/"},{"name":"gpu","slug":"gpu","link":"/tags/gpu/"},{"name":"cuda","slug":"cuda","link":"/tags/cuda/"},{"name":"nlp","slug":"nlp","link":"/tags/nlp/"},{"name":"baidu","slug":"baidu","link":"/tags/baidu/"},{"name":"sentiment","slug":"sentiment","link":"/tags/sentiment/"},{"name":"line","slug":"line","link":"/tags/line/"},{"name":"rich menu","slug":"rich-menu","link":"/tags/rich-menu/"},{"name":"chatbot","slug":"chatbot","link":"/tags/chatbot/"},{"name":"彈幕教室","slug":"彈幕教室","link":"/tags/%E5%BD%88%E5%B9%95%E6%95%99%E5%AE%A4/"},{"name":"deploy","slug":"deploy","link":"/tags/deploy/"},{"name":"rvm","slug":"rvm","link":"/tags/rvm/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"graph","slug":"graph","link":"/tags/graph/"},{"name":"data visualization","slug":"data-visualization","link":"/tags/data-visualization/"},{"name":"kill","slug":"kill","link":"/tags/kill/"},{"name":"pid","slug":"pid","link":"/tags/pid/"},{"name":"sidekiq","slug":"sidekiq","link":"/tags/sidekiq/"},{"name":"proxy","slug":"proxy","link":"/tags/proxy/"},{"name":"sendgrid","slug":"sendgrid","link":"/tags/sendgrid/"},{"name":"email","slug":"email","link":"/tags/email/"},{"name":"angular","slug":"angular","link":"/tags/angular/"},{"name":"rxjs","slug":"rxjs","link":"/tags/rxjs/"},{"name":"windows","slug":"windows","link":"/tags/windows/"},{"name":"wsl","slug":"wsl","link":"/tags/wsl/"},{"name":"rdbms","slug":"rdbms","link":"/tags/rdbms/"},{"name":"index","slug":"index","link":"/tags/index/"},{"name":"c#","slug":"c","link":"/tags/c/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"mac","slug":"mac","link":"/tags/mac/"},{"name":"illustrator","slug":"illustrator","link":"/tags/illustrator/"},{"name":"alternative","slug":"alternative","link":"/tags/alternative/"},{"name":"terminal","slug":"terminal","link":"/tags/terminal/"},{"name":"powershell","slug":"powershell","link":"/tags/powershell/"},{"name":"readme","slug":"readme","link":"/tags/readme/"},{"name":"changelog","slug":"changelog","link":"/tags/changelog/"},{"name":"code of conduct","slug":"code-of-conduct","link":"/tags/code-of-conduct/"},{"name":"contributing","slug":"contributing","link":"/tags/contributing/"},{"name":"license","slug":"license","link":"/tags/license/"},{"name":"repository","slug":"repository","link":"/tags/repository/"},{"name":"documentation","slug":"documentation","link":"/tags/documentation/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"eslint","slug":"eslint","link":"/tags/eslint/"},{"name":"prettier","slug":"prettier","link":"/tags/prettier/"},{"name":"linter","slug":"linter","link":"/tags/linter/"},{"name":"formatter","slug":"formatter","link":"/tags/formatter/"},{"name":"coding style","slug":"coding-style","link":"/tags/coding-style/"},{"name":"state management","slug":"state-management","link":"/tags/state-management/"}],"categories":[{"name":"技術文章","slug":"技術文章","link":"/categories/%E6%8A%80%E8%A1%93%E6%96%87%E7%AB%A0/"},{"name":"軟體分享","slug":"軟體分享","link":"/categories/%E8%BB%9F%E9%AB%94%E5%88%86%E4%BA%AB/"},{"name":"碩論","slug":"技術文章/碩論","link":"/categories/%E6%8A%80%E8%A1%93%E6%96%87%E7%AB%A0/%E7%A2%A9%E8%AB%96/"},{"name":"從 Ruby 到 C#","slug":"技術文章/從-Ruby-到-C","link":"/categories/%E6%8A%80%E8%A1%93%E6%96%87%E7%AB%A0/%E5%BE%9E-Ruby-%E5%88%B0-C/"}],"pages":[]}